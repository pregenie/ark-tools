---
description: Create a complete vertical slice module (Model, Service, API, Tests) with production quality
allowed-tools: Read, Write, Bash
model: opus-4.5-with-thinking
session-label: main-module-{module_name}
---
# Context
- Existing Models: !`ls -la ark-tools/database/models/*.py 2>/dev/null || echo "No models yet"`
- Existing Services: !`ls -la ark-tools/core/*_service.py 2>/dev/null || echo "No services yet"`
- Existing Blueprints: !`ls -la ark-tools/web/blueprints/*.py 2>/dev/null || echo "No blueprints yet"`
- Production Standards: Type hints, error handling, logging, testing

# Parameters
- module_name: {{module_name}}
- description: {{description|default:"Module for " + module_name}}
- include_websocket: {{include_websocket|default:false}}

# Task
Create a full vertical slice for the module "{{module_name}}" with production quality:

1. Database Model with full typing:
```python
# ark-tools/database/models/{{module_name}}.py
from sqlalchemy import Column, String, DateTime, JSON, Text, Boolean, Integer, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
import uuid
from datetime import datetime
from typing import Dict, Any, Optional, List
from enum import Enum
from .base import Base

class {{module_name|capitalize}}(Base):
    """{{description}}"""
    __tablename__ = '{{module_name}}s'
    
    # Primary key with UUID for scalability
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Foreign key to project if applicable
    project_id = Column(UUID(as_uuid=True), ForeignKey('projects.id'), nullable=False, index=True)
    
    # Core fields
    name = Column(String(255), nullable=False, index=True)
    description = Column(Text)
    status = Column(String(50), default='pending', index=True)
    
    # Metadata as JSONB for flexible querying
    metadata = Column(JSONB, default={})
    results = Column(JSONB, default={})
    
    # Metrics
    processed_count = Column(Integer, default=0)
    error_count = Column(Integer, default=0)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    completed_at = Column(DateTime)
    
    # Relationships
    project = relationship("Project", back_populates="{{module_name}}s")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses"""
        return {
            'id': str(self.id),
            'project_id': str(self.project_id),
            'name': self.name,
            'description': self.description,
            'status': self.status,
            'metadata': self.metadata,
            'results': self.results,
            'metrics': {
                'processed_count': self.processed_count,
                'error_count': self.error_count
            },
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'completed_at': self.completed_at.isoformat() if self.completed_at else None
        }
    
    def __repr__(self) -> str:
        return f"<{{module_name|capitalize}}(id={self.id}, name={self.name}, status={self.status})>"
```

2. Service Layer with business logic:
```python
# ark-tools/core/{{module_name}}_service.py
"""Service layer for {{module_name}} operations"""
from typing import List, Dict, Any, Optional
from uuid import UUID
from datetime import datetime
import logging
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from database.models.{{module_name}} import {{module_name|capitalize}}
from database.models.project import Project

logger = logging.getLogger(__name__)

class {{module_name|capitalize}}Service:
    """Service for managing {{module_name}} operations with production error handling"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def create(self, project_id: UUID, data: Dict[str, Any]) -> {{module_name|capitalize}}:
        """Create a new {{module_name}} with validation"""
        try:
            # Validate project exists
            project = self.session.query(Project).filter_by(id=project_id).first()
            if not project:
                raise ValueError(f"Project {project_id} not found")
            
            # Create entity
            entity = {{module_name|capitalize}}(
                project_id=project_id,
                name=data.get('name', f"{{module_name}}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"),
                description=data.get('description'),
                metadata=data.get('metadata', {})
            )
            
            self.session.add(entity)
            self.session.commit()
            
            logger.info(f"Created {{module_name}} {entity.id} for project {project_id}")
            return entity
            
        except IntegrityError as e:
            self.session.rollback()
            logger.error(f"Integrity error creating {{module_name}}: {e}")
            raise ValueError("{{module_name|capitalize}} with this name already exists")
        except SQLAlchemyError as e:
            self.session.rollback()
            logger.error(f"Database error creating {{module_name}}: {e}")
            raise
    
    def get(self, entity_id: UUID) -> Optional[{{module_name|capitalize}}]:
        """Get {{module_name}} by ID with error handling"""
        try:
            return self.session.query({{module_name|capitalize}}).filter_by(id=entity_id).first()
        except SQLAlchemyError as e:
            logger.error(f"Error fetching {{module_name}} {entity_id}: {e}")
            raise
    
    def list_by_project(self, project_id: UUID, limit: int = 100, offset: int = 0) -> List[{{module_name|capitalize}}]:
        """List {{module_name}}s for a project with pagination"""
        try:
            return (
                self.session.query({{module_name|capitalize}})
                .filter_by(project_id=project_id)
                .order_by({{module_name|capitalize}}.created_at.desc())
                .limit(limit)
                .offset(offset)
                .all()
            )
        except SQLAlchemyError as e:
            logger.error(f"Error listing {{module_name}}s for project {project_id}: {e}")
            raise
    
    def update_status(self, entity_id: UUID, status: str, results: Optional[Dict[str, Any]] = None) -> {{module_name|capitalize}}:
        """Update {{module_name}} status with optional results"""
        try:
            entity = self.get(entity_id)
            if not entity:
                raise ValueError(f"{{module_name|capitalize}} {entity_id} not found")
            
            entity.status = status
            if results:
                entity.results = results
            
            if status == 'completed':
                entity.completed_at = datetime.utcnow()
            
            self.session.commit()
            logger.info(f"Updated {{module_name}} {entity_id} status to {status}")
            return entity
            
        except SQLAlchemyError as e:
            self.session.rollback()
            logger.error(f"Error updating {{module_name}} {entity_id}: {e}")
            raise
    
    def delete(self, entity_id: UUID) -> bool:
        """Delete {{module_name}} with cascade handling"""
        try:
            entity = self.get(entity_id)
            if not entity:
                return False
            
            self.session.delete(entity)
            self.session.commit()
            logger.info(f"Deleted {{module_name}} {entity_id}")
            return True
            
        except SQLAlchemyError as e:
            self.session.rollback()
            logger.error(f"Error deleting {{module_name}} {entity_id}: {e}")
            raise
```

3. Flask Blueprint with REST API:
```python
# ark-tools/web/blueprints/{{module_name}}.py
"""API Blueprint for {{module_name}} operations"""
from flask import Blueprint, jsonify, request, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from typing import Dict, Any, Tuple
from uuid import UUID
import logging
from database.models.base import DatabaseManager
from core.{{module_name}}_service import {{module_name|capitalize}}Service

logger = logging.getLogger(__name__)

bp = Blueprint('{{module_name}}', __name__)

@bp.route('/<project_id>/{{module_name}}', methods=['POST'])
@jwt_required()
def create_{{module_name}}(project_id: str) -> Tuple[Dict[str, Any], int]:
    """Create a new {{module_name}} for a project"""
    try:
        # Validate input
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # Get database session
        db = DatabaseManager(current_app.config['DATABASE_URL'])
        with db.get_session() as session:
            service = {{module_name|capitalize}}Service(session)
            
            # Create entity
            entity = service.create(
                project_id=UUID(project_id),
                data=data
            )
            
            return jsonify(entity.to_dict()), 201
            
    except ValueError as e:
        logger.warning(f"Validation error: {e}")
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        logger.error(f"Error creating {{module_name}}: {e}")
        return jsonify({'error': 'Internal server error'}), 500

@bp.route('/{{module_name}}/<entity_id>', methods=['GET'])
@jwt_required()
def get_{{module_name}}(entity_id: str) -> Tuple[Dict[str, Any], int]:
    """Get {{module_name}} by ID"""
    try:
        db = DatabaseManager(current_app.config['DATABASE_URL'])
        with db.get_session() as session:
            service = {{module_name|capitalize}}Service(session)
            entity = service.get(UUID(entity_id))
            
            if not entity:
                return jsonify({'error': '{{module_name|capitalize}} not found'}), 404
            
            return jsonify(entity.to_dict()), 200
            
    except ValueError as e:
        return jsonify({'error': 'Invalid ID format'}), 400
    except Exception as e:
        logger.error(f"Error fetching {{module_name}} {entity_id}: {e}")
        return jsonify({'error': 'Internal server error'}), 500

@bp.route('/<project_id>/{{module_name}}', methods=['GET'])
@jwt_required()
def list_{{module_name}}s(project_id: str) -> Tuple[Dict[str, Any], int]:
    """List {{module_name}}s for a project with pagination"""
    try:
        # Get pagination parameters
        limit = min(int(request.args.get('limit', 100)), 1000)
        offset = int(request.args.get('offset', 0))
        
        db = DatabaseManager(current_app.config['DATABASE_URL'])
        with db.get_session() as session:
            service = {{module_name|capitalize}}Service(session)
            entities = service.list_by_project(
                project_id=UUID(project_id),
                limit=limit,
                offset=offset
            )
            
            return jsonify({
                '{{module_name}}s': [e.to_dict() for e in entities],
                'pagination': {
                    'limit': limit,
                    'offset': offset,
                    'count': len(entities)
                }
            }), 200
            
    except ValueError as e:
        return jsonify({'error': 'Invalid parameters'}), 400
    except Exception as e:
        logger.error(f"Error listing {{module_name}}s: {e}")
        return jsonify({'error': 'Internal server error'}), 500

@bp.route('/{{module_name}}/<entity_id>/status', methods=['PATCH'])
@jwt_required()
def update_{{module_name}}_status(entity_id: str) -> Tuple[Dict[str, Any], int]:
    """Update {{module_name}} status"""
    try:
        data = request.get_json()
        if not data or 'status' not in data:
            return jsonify({'error': 'Status required'}), 400
        
        db = DatabaseManager(current_app.config['DATABASE_URL'])
        with db.get_session() as session:
            service = {{module_name|capitalize}}Service(session)
            entity = service.update_status(
                entity_id=UUID(entity_id),
                status=data['status'],
                results=data.get('results')
            )
            
            return jsonify(entity.to_dict()), 200
            
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        logger.error(f"Error updating {{module_name}} {entity_id}: {e}")
        return jsonify({'error': 'Internal server error'}), 500

@bp.route('/{{module_name}}/<entity_id>', methods=['DELETE'])
@jwt_required()
def delete_{{module_name}}(entity_id: str) -> Tuple[Dict[str, Any], int]:
    """Delete {{module_name}}"""
    try:
        db = DatabaseManager(current_app.config['DATABASE_URL'])
        with db.get_session() as session:
            service = {{module_name|capitalize}}Service(session)
            deleted = service.delete(UUID(entity_id))
            
            if not deleted:
                return jsonify({'error': '{{module_name|capitalize}} not found'}), 404
            
            return jsonify({'message': '{{module_name|capitalize}} deleted successfully'}), 200
            
    except Exception as e:
        logger.error(f"Error deleting {{module_name}} {entity_id}: {e}")
        return jsonify({'error': 'Internal server error'}), 500

{% if include_websocket %}
# WebSocket events for real-time updates
from flask_socketio import emit, join_room, leave_room

@bp.route('/{{module_name}}/<entity_id>/subscribe', methods=['POST'])
@jwt_required()
def subscribe_to_{{module_name}}(entity_id: str) -> Tuple[Dict[str, Any], int]:
    """Subscribe to real-time updates for a {{module_name}}"""
    room = f"{{module_name}}_{entity_id}"
    # This would be handled by SocketIO in practice
    return jsonify({'room': room, 'subscribed': True}), 200
{% endif %}
```

4. Comprehensive tests:
```python
# ark-tools/tests/unit/test_{{module_name}}.py
"""Unit tests for {{module_name}} module"""
import pytest
from uuid import uuid4
from datetime import datetime
from unittest.mock import Mock, patch
from core.{{module_name}}_service import {{module_name|capitalize}}Service
from database.models.{{module_name}} import {{module_name|capitalize}}

class Test{{module_name|capitalize}}Service:
    """Test suite for {{module_name|capitalize}}Service"""
    
    @pytest.fixture
    def mock_session(self):
        """Create mock database session"""
        return Mock()
    
    @pytest.fixture
    def service(self, mock_session):
        """Create service instance with mock session"""
        return {{module_name|capitalize}}Service(mock_session)
    
    def test_create_{{module_name}}_success(self, service, mock_session):
        """Test successful creation of {{module_name}}"""
        # Arrange
        project_id = uuid4()
        mock_project = Mock(id=project_id)
        mock_session.query().filter_by().first.return_value = mock_project
        
        data = {
            'name': 'Test {{module_name}}',
            'description': 'Test description',
            'metadata': {'key': 'value'}
        }
        
        # Act
        result = service.create(project_id, data)
        
        # Assert
        assert result is not None
        mock_session.add.assert_called_once()
        mock_session.commit.assert_called_once()
    
    def test_create_{{module_name}}_project_not_found(self, service, mock_session):
        """Test creation fails when project doesn't exist"""
        # Arrange
        project_id = uuid4()
        mock_session.query().filter_by().first.return_value = None
        
        # Act & Assert
        with pytest.raises(ValueError, match="Project .* not found"):
            service.create(project_id, {})
    
    def test_get_{{module_name}}_found(self, service, mock_session):
        """Test getting existing {{module_name}}"""
        # Arrange
        entity_id = uuid4()
        mock_entity = Mock(id=entity_id)
        mock_session.query().filter_by().first.return_value = mock_entity
        
        # Act
        result = service.get(entity_id)
        
        # Assert
        assert result == mock_entity
    
    def test_update_status_completed(self, service, mock_session):
        """Test updating status to completed sets timestamp"""
        # Arrange
        entity_id = uuid4()
        mock_entity = Mock(id=entity_id, status='pending')
        service.get = Mock(return_value=mock_entity)
        
        # Act
        result = service.update_status(entity_id, 'completed', {'score': 100})
        
        # Assert
        assert mock_entity.status == 'completed'
        assert mock_entity.results == {'score': 100}
        assert mock_entity.completed_at is not None
        mock_session.commit.assert_called_once()
    
    def test_delete_{{module_name}}_success(self, service, mock_session):
        """Test successful deletion"""
        # Arrange
        entity_id = uuid4()
        mock_entity = Mock(id=entity_id)
        service.get = Mock(return_value=mock_entity)
        
        # Act
        result = service.delete(entity_id)
        
        # Assert
        assert result is True
        mock_session.delete.assert_called_once_with(mock_entity)
        mock_session.commit.assert_called_once()

# ark-tools/tests/integration/test_{{module_name}}_api.py
"""Integration tests for {{module_name}} API"""
import pytest
import json
from uuid import uuid4

class Test{{module_name|capitalize}}API:
    """Integration tests for {{module_name}} REST API"""
    
    @pytest.fixture
    def auth_headers(self, client):
        """Get authentication headers"""
        # In real tests, would get actual JWT token
        return {'Authorization': 'Bearer test_token'}
    
    def test_create_{{module_name}}_api(self, client, auth_headers):
        """Test creating {{module_name}} via API"""
        project_id = str(uuid4())
        data = {
            'name': 'Test {{module_name}}',
            'description': 'API test'
        }
        
        response = client.post(
            f'/api/v1/{project_id}/{{module_name}}',
            json=data,
            headers=auth_headers
        )
        
        assert response.status_code == 201
        result = json.loads(response.data)
        assert result['name'] == data['name']
        assert 'id' in result
    
    def test_list_{{module_name}}s_pagination(self, client, auth_headers):
        """Test listing with pagination"""
        project_id = str(uuid4())
        
        response = client.get(
            f'/api/v1/{project_id}/{{module_name}}?limit=10&offset=0',
            headers=auth_headers
        )
        
        assert response.status_code == 200
        result = json.loads(response.data)
        assert '{{module_name}}s' in result
        assert 'pagination' in result
        assert result['pagination']['limit'] == 10
```

5. Register the blueprint in app.py:
```python
# Update ark-tools/web/app.py
from .blueprints import {{module_name}}
app.register_blueprint({{module_name}}.bp, url_prefix='/api/v1')
```

6. Add to Project model relationship:
```python
# Update ark-tools/database/models/project.py
{{module_name}}s = relationship("{{module_name|capitalize}}", back_populates="project", cascade="all, delete-orphan")
```

7. Create database migration:
```bash
cd ark-tools
alembic revision --autogenerate -m "Add {{module_name}} module"
alembic upgrade head
```

8. Run tests to verify:
```bash
# Format code
black ark-tools/
isort ark-tools/

# Type checking
mypy ark-tools/database/models/{{module_name}}.py
mypy ark-tools/core/{{module_name}}_service.py
mypy ark-tools/web/blueprints/{{module_name}}.py

# Run tests
pytest ark-tools/tests/unit/test_{{module_name}}.py -v
pytest ark-tools/tests/integration/test_{{module_name}}_api.py -v

# Check coverage
pytest --cov=ark_tools.core.{{module_name}}_service --cov=ark_tools.web.blueprints.{{module_name}} tests/
```

# Output
Module "{{module_name}}" created successfully with:
✅ Database model with relationships
✅ Service layer with error handling
✅ REST API with authentication
✅ Comprehensive unit tests
✅ Integration tests
✅ Type hints throughout
✅ Production logging
{% if include_websocket %}✅ WebSocket support{% endif %}

Next steps:
1. Run migrations: `alembic upgrade head`
2. Run tests: `pytest tests/ -v`
3. Start server: `docker-compose up`
4. Test API: `curl http://localhost:5002/api/v1/health`