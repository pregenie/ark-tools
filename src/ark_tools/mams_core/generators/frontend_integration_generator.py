"""
Frontend Integration Generator for Unified Components
======================================================
Generates index.ts exports, routing, and service integration for React components

Author: Arkyvus Team
Date: 2026-01-10
"""

import os
import sys
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime

# Import MAMS config for proper directory structure
sys.path.insert(0, str(Path(__file__).parent.parent.parent))
try:
    from arkyvus.migrations.mams_config import MAMSConfig
except ImportError:
    # Fallback if config not available
    class MAMSConfig:
        FRONTEND_SERVICES_DIR = Path('/app/client/src/services/unified')
        FRONTEND_COMPONENTS_DIR = Path('/app/client/src/components/unified')
        FRONTEND_HOOKS_DIR = Path('/app/client/src/hooks/unified')
        INTEGRATION_REACT_FILE = Path('/app/.migration/frontend_integration.md')
        @classmethod
        def initialize_directories(cls):
            pass


INDEX_TS_TEMPLATE = '''/**
 * Unified {module_name} Module Exports
 * Auto-generated by MAMS Frontend Integration Generator
 */

// Component exports
{component_exports}

// Hook exports
{hook_exports}

// Service exports
{service_exports}

// Type exports
{type_exports}

// Aggregate exports
export const {module_name}Module = {{
  components: {{
{component_refs}
  }},
  hooks: {{
{hook_refs}
  }},
  services: {{
{service_refs}
  }},
  types: {{
{type_refs}
  }}
}};

export default {module_name}Module;
'''

ROUTER_TEMPLATE = '''/**
 * Unified {module_name} Routes
 * Auto-generated by MAMS Frontend Integration Generator
 */

import React, {{ lazy, Suspense }} from 'react';
import {{ Routes, Route }} from 'react-router-dom';
import {{ LoadingSpinner }} from '@/components/common/LoadingSpinner';

// Lazy load components for code splitting
{lazy_imports}

export const {module_name}Routes: React.FC = () => {{
  return (
    <Suspense fallback={{<LoadingSpinner />}}>
      <Routes>
{route_definitions}
      </Routes>
    </Suspense>
  );
}};

export default {module_name}Routes;
'''

SERVICE_CLIENT_TEMPLATE = '''/**
 * Unified {service_name} Service Client
 * Auto-generated by MAMS Frontend Integration Generator
 */

import {{ apiClient }} from '@/services/api/client';
import {{ APIConfig }} from '@/config/api.config';

const API_ENDPOINTS = {{
  BASE: `/api/v2/{endpoint_base}`,
  HEALTH: `/api/v2/{endpoint_base}/health`,
  INFO: `/api/v2/{endpoint_base}/info`,
{custom_endpoints}
}};

export class Unified{service_name}Service {{
  /**
   * Get service health status
   */
  async getHealth() {{
    const response = await apiClient.get(API_ENDPOINTS.HEALTH);
    return response.data;
  }}

  /**
   * Get service information
   */
  async getInfo() {{
    const response = await apiClient.get(API_ENDPOINTS.INFO);
    return response.data;
  }}

{custom_methods}
}}

// Export singleton instance
export const unified{service_name}Service = new Unified{service_name}Service();

export default unified{service_name}Service;
'''

HOOK_TEMPLATE = '''/**
 * Unified {hook_name} Hook
 * Auto-generated by MAMS Frontend Integration Generator
 */

import {{ useState, useEffect }} from 'react';
import {{ useQuery, useMutation }} from '@tanstack/react-query';
import {{ unified{service_name}Service }} from '../services/unified{service_name}Service';

export const useUnified{hook_name} = (options = {{}}) => {{
  const {{ data, isLoading, error, refetch }} = useQuery({{
    queryKey: ['unified{service_name}', options],
    queryFn: async () => {{
      // Implement based on service needs
      return unified{service_name}Service.getInfo();
    }},
    ...options
  }});

  return {{
    data,
    isLoading,
    error,
    refetch
  }};
}};

export default useUnified{hook_name};
'''


def scan_unified_directories() -> Dict[str, List[Path]]:
    """Scan for unified components, hooks, services, and types"""
    
    client_src = Path('/app/client/src')
    unified_dirs = {
        'components': [],
        'hooks': [],
        'services': [],
        'types': []
    }
    
    # Find unified directories
    for category in unified_dirs.keys():
        category_path = client_src / category
        if category_path.exists():
            # Look for unified subdirectories
            unified_path = category_path / 'unified'
            if unified_path.exists():
                unified_dirs[category].extend(unified_path.glob('*'))
            
            # Look for unified-* directories
            unified_dirs[category].extend(category_path.glob('unified-*'))
    
    return unified_dirs


def generate_index_exports(module_name: str, files: List[Path], category: str) -> str:
    """Generate export statements for index.ts"""
    
    exports = []
    refs = []
    
    for file in files:
        if file.is_file() and file.suffix in ['.ts', '.tsx']:
            # Skip index files and test files
            if 'index' in file.name or '.test.' in file.name or '.spec.' in file.name:
                continue
                
            name = file.stem
            # Convert kebab-case to PascalCase
            export_name = ''.join(word.capitalize() for word in name.split('-'))
            
            if category == 'components':
                exports.append(f"export {{ default as {export_name} }} from './{name}';")
                refs.append(f"    {export_name},")
            elif category == 'hooks':
                exports.append(f"export {{ {name} }} from './{name}';")
                refs.append(f"    {name},")
            elif category == 'services':
                exports.append(f"export {{ default as {name}Service }} from './{name}';")
                refs.append(f"    {name}Service,")
            elif category == 'types':
                exports.append(f"export * from './{name}';")
                refs.append(f"    // Types from {name}")
    
    return '\n'.join(exports), '\n'.join(refs)


def generate_module_index(module_name: str, unified_dirs: Dict[str, List[Path]]) -> str:
    """Generate index.ts for a module"""
    
    component_exports, component_refs = generate_index_exports(module_name, unified_dirs.get('components', []), 'components')
    hook_exports, hook_refs = generate_index_exports(module_name, unified_dirs.get('hooks', []), 'hooks')
    service_exports, service_refs = generate_index_exports(module_name, unified_dirs.get('services', []), 'services')
    type_exports, type_refs = generate_index_exports(module_name, unified_dirs.get('types', []), 'types')
    
    return INDEX_TS_TEMPLATE.format(
        module_name=module_name,
        component_exports=component_exports or '// No components',
        hook_exports=hook_exports or '// No hooks',
        service_exports=service_exports or '// No services',
        type_exports=type_exports or '// No types',
        component_refs=component_refs or '    // No components',
        hook_refs=hook_refs or '    // No hooks',
        service_refs=service_refs or '    // No services',
        type_refs=type_refs or '    // No types'
    )


def generate_service_client(service_name: str, endpoints: List[str] = None) -> str:
    """Generate TypeScript service client for unified backend service"""
    
    endpoint_base = service_name.lower().replace('_', '-')
    
    # Default endpoints based on service type
    default_endpoints = {
        'auth': [
            ('LOGIN', '/login', 'post', 'login'),
            ('LOGOUT', '/logout', 'post', 'logout'),
            ('VERIFY', '/verify', 'get', 'verifyToken'),
            ('REFRESH', '/refresh', 'post', 'refreshToken')
        ],
        'analytics': [
            ('METRICS', '/metrics', 'get', 'getMetrics'),
            ('EVENTS', '/events', 'post', 'trackEvents'),
            ('REPORTS', '/reports', 'get', 'getReports')
        ],
        'storage': [
            ('UPLOAD', '/upload', 'post', 'uploadFile'),
            ('DOWNLOAD', '/download/{id}', 'get', 'downloadFile'),
            ('LIST', '/list', 'get', 'listFiles'),
            ('DELETE', '/delete/{id}', 'delete', 'deleteFile')
        ]
    }
    
    service_endpoints = default_endpoints.get(service_name, [])
    
    custom_endpoints = []
    custom_methods = []
    
    for endpoint_name, path, method, method_name in service_endpoints:
        custom_endpoints.append(f"  {endpoint_name}: `${{API_ENDPOINTS.BASE}}{path}`,")
        
        if method == 'get':
            custom_methods.append(f'''
  /**
   * {method_name}
   */
  async {method_name}(params = {{}}) {{
    const response = await apiClient.get(API_ENDPOINTS.{endpoint_name}, {{ params }});
    return response.data;
  }}''')
        elif method == 'post':
            custom_methods.append(f'''
  /**
   * {method_name}
   */
  async {method_name}(data: any) {{
    const response = await apiClient.post(API_ENDPOINTS.{endpoint_name}, data);
    return response.data;
  }}''')
        elif method == 'delete':
            custom_methods.append(f'''
  /**
   * {method_name}
   */
  async {method_name}(id: string) {{
    const url = API_ENDPOINTS.{endpoint_name}.replace('{{{{id}}}}', id);
    const response = await apiClient.delete(url);
    return response.data;
  }}''')
    
    return SERVICE_CLIENT_TEMPLATE.format(
        service_name=service_name.capitalize(),
        endpoint_base=endpoint_base,
        custom_endpoints='\n'.join(custom_endpoints) if custom_endpoints else '  // No custom endpoints',
        custom_methods='\n'.join(custom_methods) if custom_methods else '  // No custom methods'
    )


def generate_all_integrations():
    """Generate all frontend integration files"""
    
    print("üé® Generating Frontend Integration Files...")
    print("=" * 60)
    
    # Initialize MAMS directories
    MAMSConfig.initialize_directories()
    
    print(f"üìÅ Generating frontend files in: {MAMSConfig.FRONTEND_BASE_DIR}")
    print(f"‚ö†Ô∏è  These are MAMS-generated files, not production!")
    
    # Scan for unified directories
    unified_dirs = scan_unified_directories()
    
    # Count what we found
    total_components = sum(len(files) for files in unified_dirs['components'])
    total_hooks = len(unified_dirs['hooks'])
    total_services = len(unified_dirs['services'])
    total_types = len(unified_dirs['types'])
    
    print(f"üìä Found:")
    print(f"  - Components: {total_components}")
    print(f"  - Hooks: {total_hooks}")
    print(f"  - Services: {total_services}")
    print(f"  - Types: {total_types}")
    
    generated_files = []
    
    # Generate index files for each unified directory
    for category, dirs in unified_dirs.items():
        for dir_path in dirs:
            if dir_path.is_dir():
                index_file = dir_path / 'index.ts'
                
                # Get files in this directory
                files = list(dir_path.glob('*.ts')) + list(dir_path.glob('*.tsx'))
                
                if files and not index_file.exists():
                    module_name = dir_path.name.replace('unified-', '').replace('unified', '')
                    module_name = ''.join(word.capitalize() for word in module_name.split('-'))
                    
                    # Generate index content
                    exports, refs = generate_index_exports(module_name, files, category)
                    
                    index_content = f'''/**
 * {module_name} {category.capitalize()} Exports
 * Auto-generated by MAMS
 */

{exports}

export default {{
{refs}
}};
'''
                    
                    # Write index file
                    index_file.write_text(index_content)
                    generated_files.append(index_file)
                    print(f"  ‚úÖ Generated {index_file}")
    
    # Generate service clients for backend unified services
    services_dir = Path('/app/client/src/services/unified')
    services_dir.mkdir(parents=True, exist_ok=True)
    
    # Get list of backend unified services
    backend_services = []
    backend_unified_dir = Path('/app/arkyvus/services/unified')
    if backend_unified_dir.exists():
        for service_file in backend_unified_dir.glob('*_service.py'):
            service_name = service_file.stem.replace('_service', '')
            backend_services.append(service_name)
    
    # Generate TypeScript service clients
    for service_name in backend_services[:10]:  # Limit to first 10 for now
        client_file = services_dir / f'{service_name}Service.ts'
        if not client_file.exists():
            client_content = generate_service_client(service_name)
            client_file.write_text(client_content)
            generated_files.append(client_file)
            print(f"  ‚úÖ Generated service client: {client_file.name}")
    
    # Generate main unified services index
    if backend_services:
        services_index = services_dir / 'index.ts'
        index_content = '''/**
 * Unified Services Export
 * Auto-generated by MAMS
 */

'''
        for service_name in backend_services[:10]:
            index_content += f"export {{ default as {service_name}Service }} from './{service_name}Service';\n"
        
        services_index.write_text(index_content)
        generated_files.append(services_index)
    
    # Generate integration instructions
    integration_file = Path('/app/.migration/frontend_integration.md')
    integration_file.parent.mkdir(exist_ok=True)
    
    integration_content = f'''# Frontend Integration Instructions

## Generated Files
- Index files: {len([f for f in generated_files if 'index.ts' in f.name])}
- Service clients: {len([f for f in generated_files if 'Service.ts' in f.name])}

## Next Steps

1. **Import unified services in components:**
```typescript
import {{ authService }} from '@/services/unified/authService';
```

2. **Use unified hooks:**
```typescript
import {{ useUnifiedAuth }} from '@/hooks/unified/useUnifiedAuth';
```

3. **Add routes for unified components:**
```typescript
// In App.tsx or routes file
import {{ UnifiedAuthRoutes }} from '@/components/unified-auth/routes';

<Routes>
  <Route path="/auth/*" element={{<UnifiedAuthRoutes />}} />
</Routes>
```

4. **Update API configuration:**
- Ensure apiClient is configured for v2 endpoints
- Update CORS settings if needed

Generated: {datetime.now().isoformat()}
'''
    
    integration_file.write_text(integration_content)
    
    print(f"\n‚úÖ Successfully generated {len(generated_files)} integration files")
    print(f"üìù Instructions saved to: {integration_file}")
    
    return generated_files


if __name__ == '__main__':
    generate_all_integrations()