"""
Configuration Builder and Validator
====================================

Builds and validates ARK-TOOLS configuration based on detected services
and user preferences.
"""

import os
import secrets
import string
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass, field
from enum import Enum
import yaml
import json
import logging
from urllib.parse import urlparse, urlunparse

from ark_tools.setup.detector import DetectedService, DetectedEnvironment

logger = logging.getLogger(__name__)

class ServiceMode(Enum):
    """Service configuration mode"""
    USE_EXISTING = "use_existing"
    CREATE_NEW = "create_new"
    SHARE_EXISTING = "share_existing"
    SKIP = "skip"
    REMOTE = "remote"

@dataclass
class ServiceConfig:
    """Configuration for a single service"""
    service_type: str
    mode: ServiceMode
    host: str = "localhost"
    port: int = None
    credentials: Dict[str, str] = field(default_factory=dict)
    inherit_from: Optional[str] = None  # Path to env file
    container_name: Optional[str] = None
    create_database: Optional[str] = None
    database_number: Optional[int] = None  # For Redis
    install_extensions: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            'service_type': self.service_type,
            'mode': self.mode.value,
            'host': self.host,
            'port': self.port,
            'credentials': {k: '***MASKED***' if 'password' in k.lower() else v 
                           for k, v in self.credentials.items()},
            'inherit_from': self.inherit_from,
            'container_name': self.container_name,
            'create_database': self.create_database,
            'database_number': self.database_number,
            'install_extensions': self.install_extensions,
            'warnings': self.warnings
        }

@dataclass
class ARKToolsConfig:
    """Complete ARK-TOOLS configuration"""
    # Service configurations
    postgresql: Optional[ServiceConfig] = None
    redis: Optional[ServiceConfig] = None
    
    # Inherited values
    inherited_env_file: Optional[str] = None
    inherited_variables: Dict[str, str] = field(default_factory=dict)
    
    # Generated secrets
    ark_secret_key: Optional[str] = None
    ark_jwt_secret: Optional[str] = None
    
    # AI configurations
    openai_api_key: Optional[str] = None
    anthropic_api_key: Optional[str] = None
    
    # Feature flags
    enable_websockets: bool = True
    enable_monitoring: bool = True
    enable_security_scan: bool = True
    
    # Deployment configuration
    deployment_mode: str = "integrated"  # standalone, integrated, hybrid
    create_docker_compose: bool = True
    docker_compose_profile: str = "existing-infra"  # full-stack, minimal, existing-infra
    
    # MAMS integration
    mams_base_path: Optional[str] = None
    mams_migrations_path: Optional[str] = None
    
    def to_env_content(self) -> str:
        """Generate .env file content"""
        lines = [
            "# ARK-TOOLS Configuration",
            "# Generated by ARK-TOOLS Setup Assistant",
            "# ======================================",
            ""
        ]
        
        # Security section
        lines.extend([
            "# Security Configuration",
            f"ARK_SECRET_KEY={self.ark_secret_key}",
            f"ARK_JWT_SECRET_KEY={self.ark_jwt_secret}",
            ""
        ])
        
        # Database configuration
        if self.postgresql:
            lines.append("# Database Configuration")
            if self.postgresql.mode == ServiceMode.USE_EXISTING:
                lines.append(f"# Using existing PostgreSQL from {self.postgresql.inherit_from}")
            
            db_url = self._build_database_url(self.postgresql)
            lines.extend([
                f"ARK_DATABASE_URL={db_url}",
                ""
            ])
        
        # Redis configuration
        if self.redis:
            lines.append("# Redis Configuration")
            if self.redis.mode == ServiceMode.SHARE_EXISTING:
                lines.append(f"# Sharing Redis from {self.redis.inherit_from}")
            
            redis_url = self._build_redis_url(self.redis)
            lines.extend([
                f"ARK_REDIS_URL={redis_url}",
                ""
            ])
        
        # AI configuration
        if self.openai_api_key or self.anthropic_api_key:
            lines.append("# AI Provider Configuration")
            if self.openai_api_key:
                if self.inherited_env_file and 'OPENAI' in self.inherited_variables:
                    lines.append(f"# OpenAI key inherited from {self.inherited_env_file}")
                lines.append(f"OPENAI_API_KEY={self.openai_api_key}")
            
            if self.anthropic_api_key:
                if self.inherited_env_file and 'ANTHROPIC' in self.inherited_variables:
                    lines.append(f"# Anthropic key inherited from {self.inherited_env_file}")
                lines.append(f"ANTHROPIC_API_KEY={self.anthropic_api_key}")
            
            lines.append("")
        
        # MAMS integration
        if self.mams_base_path:
            lines.extend([
                "# MAMS Integration",
                f"MAMS_BASE_PATH={self.mams_base_path}",
                f"MAMS_MIGRATIONS_PATH={self.mams_migrations_path}",
                ""
            ])
        
        # Feature flags
        lines.extend([
            "# Feature Flags",
            f"ARK_ENABLE_WEBSOCKETS={str(self.enable_websockets).lower()}",
            f"ARK_ENABLE_MONITORING={str(self.enable_monitoring).lower()}",
            f"ARK_ENABLE_SECURITY_SCAN={str(self.enable_security_scan).lower()}",
            ""
        ])
        
        # Deployment mode
        lines.extend([
            "# Deployment Configuration",
            f"ARK_DEPLOYMENT_MODE={self.deployment_mode}",
            ""
        ])
        
        # Add inherited variables that aren't already set
        if self.inherited_variables:
            lines.append("# Additional Inherited Variables")
            for key, value in self.inherited_variables.items():
                if key not in ['DATABASE_URL', 'REDIS_URL', 'OPENAI_API_KEY', 'ANTHROPIC_API_KEY']:
                    lines.append(f"{key}={value}")
        
        return '\n'.join(lines)
    
    def _build_database_url(self, config: ServiceConfig) -> str:
        """Build PostgreSQL connection URL"""
        username = config.credentials.get('username', 'ark_admin')
        password = config.credentials.get('password', 'ark_password')
        database = config.create_database or config.credentials.get('database', 'ark_tools')
        
        return f"postgresql://{username}:{password}@{config.host}:{config.port}/{database}"
    
    def _build_redis_url(self, config: ServiceConfig) -> str:
        """Build Redis connection URL"""
        password = config.credentials.get('password', '')
        db_number = config.database_number or config.credentials.get('database', '0')
        
        if password:
            return f"redis://:{password}@{config.host}:{config.port}/{db_number}"
        else:
            return f"redis://{config.host}:{config.port}/{db_number}"
    
    def to_docker_compose_override(self) -> str:
        """Generate docker-compose override for existing infrastructure"""
        compose = {
            'version': '3.8',
            'services': {}
        }
        
        # Configure API service
        api_config = {
            'environment': []
        }
        
        if self.postgresql and self.postgresql.mode == ServiceMode.USE_EXISTING:
            # Use external PostgreSQL
            api_config['external_links'] = api_config.get('external_links', [])
            if self.postgresql.container_name:
                api_config['external_links'].append(f"{self.postgresql.container_name}:postgres")
        
        if self.redis and self.redis.mode == ServiceMode.SHARE_EXISTING:
            # Use external Redis
            api_config['external_links'] = api_config.get('external_links', [])
            if self.redis.container_name:
                api_config['external_links'].append(f"{self.redis.container_name}:redis")
        
        compose['services']['api'] = api_config
        
        # Remove unnecessary services based on configuration
        if self.postgresql and self.postgresql.mode in [ServiceMode.USE_EXISTING, ServiceMode.SHARE_EXISTING]:
            compose['services']['postgres'] = {'deploy': {'replicas': 0}}
        
        if self.redis and self.redis.mode in [ServiceMode.USE_EXISTING, ServiceMode.SHARE_EXISTING]:
            compose['services']['redis'] = {'deploy': {'replicas': 0}}
        
        if not self.enable_monitoring:
            compose['services']['prometheus'] = {'deploy': {'replicas': 0}}
            compose['services']['grafana'] = {'deploy': {'replicas': 0}}
        
        return yaml.dump(compose, default_flow_style=False)
    
    def save(self, output_dir: Path) -> Tuple[bool, List[str]]:
        """
        Save configuration to files
        
        Args:
            output_dir: Directory to save configuration
            
        Returns:
            Tuple of (success, list of created files)
        """
        created_files = []
        
        try:
            output_dir = Path(output_dir)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Save .env file
            env_path = output_dir / '.env'
            with open(env_path, 'w') as f:
                f.write(self.to_env_content())
            created_files.append(str(env_path))
            
            # Save docker-compose override if needed
            if self.create_docker_compose and self.deployment_mode == 'integrated':
                compose_path = output_dir / 'docker-compose.override.yml'
                with open(compose_path, 'w') as f:
                    f.write(self.to_docker_compose_override())
                created_files.append(str(compose_path))
            
            # Save configuration summary as JSON
            config_path = output_dir / '.ark-tools-config.json'
            with open(config_path, 'w') as f:
                json.dump(self.to_dict(), f, indent=2)
            created_files.append(str(config_path))
            
            return True, created_files
            
        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
            return False, created_files
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            'postgresql': self.postgresql.to_dict() if self.postgresql else None,
            'redis': self.redis.to_dict() if self.redis else None,
            'inherited_env_file': self.inherited_env_file,
            'deployment_mode': self.deployment_mode,
            'docker_compose_profile': self.docker_compose_profile,
            'enable_websockets': self.enable_websockets,
            'enable_monitoring': self.enable_monitoring,
            'enable_security_scan': self.enable_security_scan,
            'mams_base_path': self.mams_base_path
        }

class SetupConfigurator:
    """
    Builds ARK-TOOLS configuration based on detected services and user choices
    """
    
    def __init__(self):
        self.config = ARKToolsConfig()
    
    def generate_secrets(self) -> None:
        """Generate secure secret keys"""
        # Generate 64-character hex keys
        self.config.ark_secret_key = secrets.token_hex(32)
        self.config.ark_jwt_secret = secrets.token_hex(32)
    
    def configure_from_detected_service(self, 
                                         service: DetectedService,
                                         mode: ServiceMode,
                                         **options) -> ServiceConfig:
        """
        Create service configuration from detected service
        
        Args:
            service: Detected service
            mode: How to use the service
            **options: Additional configuration options
            
        Returns:
            ServiceConfig
        """
        config = ServiceConfig(
            service_type=service.service_type,
            mode=mode,
            host=service.host,
            port=service.port
        )
        
        # Handle different modes
        if mode == ServiceMode.USE_EXISTING:
            config.inherit_from = service.env_file
            config.credentials = service.credentials or {}
            config.container_name = service.container_name
            
            # For PostgreSQL, create new database
            if service.service_type == 'postgresql':
                config.create_database = options.get('database_name', 'ark_tools')
                
                # Check for pgvector
                if 'pgvector' not in (service.version or ''):
                    config.warnings.append('pgvector extension may need manual installation')
        
        elif mode == ServiceMode.SHARE_EXISTING:
            config.inherit_from = service.env_file
            config.credentials = service.credentials or {}
            config.container_name = service.container_name
            
            # For Redis, use different database number
            if service.service_type == 'redis':
                config.database_number = options.get('database_number', 2)
        
        elif mode == ServiceMode.CREATE_NEW:
            # Use different port to avoid conflicts
            if service.service_type == 'postgresql':
                config.port = options.get('port', 5433)
                config.credentials = {
                    'username': 'ark_admin',
                    'password': secrets.token_urlsafe(16),
                    'database': 'ark_tools'
                }
            elif service.service_type == 'redis':
                config.port = options.get('port', 6380)
        
        return config
    
    def inherit_from_env(self, env: DetectedEnvironment, inherit_keys: List[str]) -> None:
        """
        Inherit configuration from environment file
        
        Args:
            env: Environment to inherit from
            inherit_keys: List of keys to inherit
        """
        self.config.inherited_env_file = env.path
        
        # Map of env keys to config attributes
        key_mapping = {
            'OPENAI_API_KEY': 'openai_api_key',
            'ANTHROPIC_API_KEY': 'anthropic_api_key',
            'CLAUDE_API_KEY': 'anthropic_api_key',  # Alternative name
        }
        
        for key in inherit_keys:
            if key in env.variables:
                value = env.variables[key]
                
                # Map to configuration
                if key in key_mapping:
                    setattr(self.config, key_mapping[key], value)
                else:
                    # Store as additional inherited variable
                    self.config.inherited_variables[key] = value
    
    def detect_mams_path(self) -> bool:
        """
        Try to detect MAMS path automatically
        
        Returns:
            True if MAMS found
        """
        possible_paths = [
            Path('../arkyvus_project/arkyvus'),
            Path('../arkyvus/arkyvus'),
            Path('../../arkyvus_project/arkyvus'),
        ]
        
        for path in possible_paths:
            migrations_path = path / 'migrations'
            if migrations_path.exists():
                self.config.mams_base_path = str(path.resolve())
                self.config.mams_migrations_path = str(migrations_path.resolve())
                return True
        
        return False
    
    def create_minimal_config(self) -> None:
        """Create minimal configuration without external dependencies"""
        # Use SQLite for database (fallback mode)
        self.config.deployment_mode = 'standalone'
        self.config.docker_compose_profile = 'minimal'
        
        # Disable features that require infrastructure
        self.config.enable_monitoring = False
        
        # Generate secrets
        self.generate_secrets()
    
    def validate_config(self) -> Tuple[bool, List[str]]:
        """
        Validate the configuration
        
        Returns:
            Tuple of (is_valid, list of issues)
        """
        issues = []
        
        # Check required secrets
        if not self.config.ark_secret_key:
            issues.append("ARK_SECRET_KEY not set")
        if not self.config.ark_jwt_secret:
            issues.append("ARK_JWT_SECRET_KEY not set")
        
        # Check database configuration
        if not self.config.postgresql:
            issues.append("No PostgreSQL configuration (will use SQLite fallback)")
        elif self.config.postgresql.mode == ServiceMode.USE_EXISTING:
            if not self.config.postgresql.credentials:
                issues.append("PostgreSQL credentials not provided")
        
        # Check MAMS integration
        if self.config.mams_base_path:
            if not Path(self.config.mams_base_path).exists():
                issues.append(f"MAMS path does not exist: {self.config.mams_base_path}")
        
        # Warnings for optional features
        if not self.config.redis:
            issues.append("No Redis configuration (caching disabled)")
        
        if not self.config.openai_api_key and not self.config.anthropic_api_key:
            issues.append("No AI provider keys (AI features disabled)")
        
        return len(issues) == 0, issues